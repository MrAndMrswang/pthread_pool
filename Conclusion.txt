实现原理
管理一个任务队列，一个线程队列，然后每次取一个任务分配给一个线程去做，循环往复。
让每一个 thread 都去执行调度函数：循环获取一个 task，然后执行之。
idea 是不是很赞！保证了 thread 函数的唯一性，而且复用线程执行 task 。
即使理解了 idea，代码还是需要详细解释一下的。
一个线程 pool，一个任务队列 queue ，应该没有意见；
任务队列是典型的生产者-消费者模型，本模型至少需要两个工具：
一个 mutex + 一个条件变量，或是一个 mutex + 一个信号量。mutex 实际上就是锁，保证任务的添加和移除
(获取)的互斥性，一个条件变量是保证获取 task 的同步性：一个 empty 的队列，线程应该等待(阻塞)；

atomic<bool> 本身是原子类型，从名字上就懂：它们的操作 load()/store() 是原子操作，所以不需要再加 mutex
可以直接对其进行操作。




主要实现方式还是生产者和消费者模式（commit分配任务，threadpool分配线程）
其中commit控制任务函数压入queue中，先入先出原则，threadpool是一个vector<thread>。
其实现有很多c++11的技巧，比如利用
1、右值引用，涉及到了移动语义，还有完美转发,vector.emplace_back()。
2、其中利用很多新增的高并发设计思想，比如atomic，future结合packaged_task()，对函数值进行获取。
	还有条件变量 condition_variable,还有unique_lock进行局部的锁定。
3、利用泛型编程思想，可以适用多种类型的函数。变参数的函数。
4、任务的执行主要利用lambda函数，捕获这个类及其内容。利用捕获到的task队列，进行出队，然后执行任务。



