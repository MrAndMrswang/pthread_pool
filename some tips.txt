实现原理
管理一个任务队列，一个线程队列，然后每次取一个任务分配给一个线程去做，循环往复。
让每一个 thread 都去执行调度函数：循环获取一个 task，然后执行之。
idea 是不是很赞！保证了 thread 函数的唯一性，而且复用线程执行 task 。
即使理解了 idea，代码还是需要详细解释一下的。
一个线程 pool，一个任务队列 queue ，应该没有意见；
任务队列是典型的生产者-消费者模型，本模型至少需要两个工具：
一个 mutex + 一个条件变量，或是一个 mutex + 一个信号量。mutex 实际上就是锁，保证任务的添加和移除
(获取)的互斥性，一个条件变量是保证获取 task 的同步性：一个 empty 的队列，线程应该等待(阻塞)；

atomic<bool> 本身是原子类型，从名字上就懂：它们的操作 load()/store() 是原子操作，所以不需要再加 mutex。